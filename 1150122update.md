# 1150122 更新：標註在暫停時消失問題分析與解決方案

## 問題描述

讀取 `.dcm` 檔案後，影像檔自動播放時，標註的直線、矩形等圖案可以正常顯示在 FAST view。但是，**暫停影像檔播放時，原本標註的直線、矩形等圖案會立即消失**。

### 用戶回報的問題特徵
1. 使用 **Grayscale** colormap（非彩色映射）
2. 暫停後標註**立即**消失
3. 暫停後嘗試滑鼠移動、調整視窗大小、點擊視窗或拖動 frame slider，標註**不會**重新出現

---

## 問題分析

### 排除的假設：LUT Overlay 覆蓋

最初懷疑是 LUT overlay（QLabel + QPixmap）覆蓋了 FAST 的 LineRenderer 標註。但經過分析：

```python
self._set_lut_overlay_enabled(self.current_colormap != ColormapType.GRAYSCALE)
```

**LUT Overlay 只有在使用 colormap（非灰階）時才會啟用**。用戶使用 Grayscale 模式，所以 LUT overlay 是隱藏的（`setVisible(False)`），可以排除此原因。

### 根本原因：FAST 的渲染是「資料驅動」的

FAST 的 `ComputationThread` 渲染循環是由**資料流**驅動的：

1. **播放時**：
   - `ImageStreamer` 持續產生新 frame
   - 觸發整個渲染管線執行
   - `ImageRenderer`（影像）和 `LineRenderer`（標註）都被渲染

2. **暫停時**：
   - `ImageStreamer.setPause(True)` 停止產生新 frame
   - **管線不再被觸發**
   - View 不會重繪，`LineRenderer` 的標註消失

`LineRenderer` 雖然使用 `addInputData(mesh)` 加入靜態資料，但它的渲染**仍然依賴於 ComputationThread 的執行循環**。當沒有新資料流動時，整個渲染管線暫停，包括 `LineRenderer`。

---

## 架構變更

### 修改前架構：FAST LineRenderer（OpenGL 層）

```
┌─────────────────────────────────────┐
│  Qt AnnotationOverlay (文字標籤)     │  ← Qt Widget 層（最上）
├─────────────────────────────────────┤
│  FAST OpenGL 渲染                    │
│  ├── LineRenderer (標註)             │  ← OpenGL 層
│  └── ImageRenderer (影像)            │
└─────────────────────────────────────┘
```

### 修改後架構：Qt AnnotationOverlay 渲染全部標註

```
┌─────────────────────────────────────┐
│  Qt AnnotationOverlay               │  ← Qt Widget 層（最上）
│  ├── 標註線條/矩形/多邊形            │
│  └── 測量線條/文字標籤               │
├─────────────────────────────────────┤
│  FAST OpenGL 渲染                    │
│  └── ImageRenderer (影像)            │  ← OpenGL 層（不再有 LineRenderer）
└─────────────────────────────────────┘
```

---

## 實作方案：完全由 Qt AnnotationOverlay 渲染

### 採用理由

| 項目 | 說明 |
|------|------|
| **1. 解決暫停問題** | 標註顯示完全獨立於 FAST 渲染循環，暫停時不會消失 |
| **2. 架構簡化** | 移除 `FASTAnnotationManager` 的 renderer 同步 |
| **3. 程式碼重用** | `AnnotationOverlay._draw_annotation()` 已經存在 |
| **4. 更好的文字支援** | Qt 的文字渲染比 FAST TextRenderer 更靈活 |
| **5. 互動性更好** | 標註選取、拖動可以直接在 Qt 層處理 |

---

## 實作過程中發現的問題

### 問題 1：雙重渲染

修改初期出現兩個矩形（一個虛線、一個實線），因為 FAST LineRenderer 和 Qt overlay 同時渲染。

**解決**：完全禁用 FAST LineRenderer，移除所有 `fast_annotation_manager` 的同步調用。

### 問題 2：縮放可以跟隨但平移不行

FAST 的 view 變換資訊分散在兩個地方：
- `getOrthoProjectionParameters()` → 只反映**縮放**（ortho 範圍變化）
- `getViewMatrix()[0][3], [1][3]` → 反映**平移**（translation）

**解決**：同時讀取 ortho params 和 view matrix，整合到 `CoordinateConverter`。

### 問題 3：座標系統不一致

滑鼠事件使用 Widget 座標，但標註需要儲存 Image 座標。

**解決**：在 `mousePressEvent` / `mouseMoveEvent` 中立即將 Widget 座標轉換為 Image 座標再儲存。

---

## 修改的檔案清單

### 1. `src/fast_annotations.py` - CoordinateConverter

```python
class CoordinateConverter:
    # 新增：FAST view matrix translation 支援
    self._view_tx = 0.0
    self._view_ty = 0.0
    
    def set_view_matrix(self, view_matrix, ortho_params=None):
        # 從 view_matrix[0][3], [1][3] 提取 translation（平移）
        # 從 ortho_params 提取 left, right, bottom, top（縮放）
        ...
    
    def image_to_widget(self, ix, iy):
        # 先應用 translation，再應用 ortho mapping
        ix_shifted = ix + self._view_tx
        iy_shifted = iy + self._view_ty
        wx = (ix_shifted - left) / (right - left) * widget_width
        wy = (top - iy_shifted) / (top - bottom) * widget_height  # Y 軸翻轉
        ...
    
    def widget_to_image(self, wx, wy):
        # 先反向 ortho mapping，再移除 translation
        ...
```

### 2. `src/annotations.py` - AnnotationOverlay

```python
def paintEvent(self, event):
    # 繪製所有已完成的標註（使用座標轉換）
    for annotation in self.annotations:
        self._draw_annotation_with_transform(painter, annotation)
    
    # 繪製所有已完成的測量
    for measure in self.measurements:
        self._draw_measure_with_transform(painter, measure)
    
    # 繪製預覽
    self._draw_preview_with_transform(painter)
    
    # 繪製測量文字標籤
    for measure in self.measurements:
        self._draw_measure_label(painter, measure)

def _transform_point(self, x, y):
    # 使用 coord_converter.image_to_widget() 轉換座標
    ...

def _widget_to_image(self, x, y):
    # 使用 coord_converter.widget_to_image() 轉換座標
    ...
```

### 3. `src/viewport.py` - ViewportManager

```python
def _update_annotation_overlays(self):
    """Timer callback: 每 50ms 更新 view matrix"""
    for viewport in self.viewports:
        view_matrix = viewport.fast_view.getViewMatrix()
        ortho_params = viewport.fast_view.getOrthoProjectionParameters()
        
        if coord_converter.set_view_matrix(view_matrix, ortho_params):
            viewport.annotation_overlay.update()  # 觸發重繪
```

### 4. `src/qt_gui.py` - MainWindow

移除所有 FAST annotation manager 的同步調用：

```python
def on_annotation_added(self, annotation):
    # 移除：fast_annotation_manager.add_annotation(annotation)
    pass  # Qt overlay 自己管理

def on_measure_added(self, measure):
    # 移除：fast_annotation_manager.add_measure(measure)
    # 只更新 Qt overlay
    ...

def on_preview_updated(self, tool_type, points):
    # 移除：fast_annotation_manager.set_preview(tool_type, points)
    pass

def on_preview_cleared(self):
    # 移除：fast_annotation_manager.clear_preview()
    pass

def clear_all_measures(self):
    # 移除：fast_annotation_manager.measurements.clear()
    # 只清除 Qt overlay
    ...
```

---

## 座標轉換公式

### FAST 座標系統分析

透過 debug 輸出確認：

| 操作 | ortho params | view_matrix translation |
|------|-------------|------------------------|
| 起始 | L=0, R=800, B=0, T=720 | tx=0, ty=0 |
| 平移 | L=0, R=800, B=0, T=720 (不變) | tx, ty 變化 |
| 放大 | 範圍變小 | - |
| 縮小 | 範圍變大 | - |

### 轉換公式

**Image → Widget：**
```python
# 1. 應用平移
ix_shifted = ix + view_tx
iy_shifted = iy + view_ty

# 2. 應用 ortho 映射 + Y 軸翻轉
wx = (ix_shifted - left) / (right - left) * widget_width
wy = (top - iy_shifted) / (top - bottom) * widget_height
```

**Widget → Image（反向）：**
```python
# 1. 反向 ortho 映射
ix_shifted = wx / widget_width * (right - left) + left
iy_shifted = top - wy / widget_height * (top - bottom)

# 2. 移除平移
ix = ix_shifted - view_tx
iy = iy_shifted - view_ty
```

---

## 測試結果

| 測試項目 | 結果 |
|---------|------|
| 標註在暫停時仍然可見 | ✅ 通過 |
| 標註正確跟隨縮放 | ✅ 通過 |
| 標註正確跟隨平移 | ✅ 通過 |
| 只有一個標註（無重複） | ✅ 通過 |
| 測量線條正確顯示 | ✅ 通過 |
| 測量文字標籤正確顯示 | ✅ 通過 |

---

## 結論

**成功實作「完全由 Qt AnnotationOverlay 渲染標註」方案**：

1. **根本解決問題**：標註不再依賴 FAST 渲染循環
2. **架構更清晰**：渲染責任明確分離
3. **縮放/平移正確**：透過 ortho params + view matrix translation 完整支援
